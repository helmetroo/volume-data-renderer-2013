<html><head><title>Project Report</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=6NUlva0wA0_-VM29T9f5GA');ul.lst-kix_xrd3a6cw62t3-8{list-style-type:none}ul.lst-kix_xrd3a6cw62t3-5{list-style-type:none}ul.lst-kix_peaeqjcyrerl-3{list-style-type:none}ul.lst-kix_xrd3a6cw62t3-4{list-style-type:none}ul.lst-kix_peaeqjcyrerl-2{list-style-type:none}ul.lst-kix_xrd3a6cw62t3-7{list-style-type:none}ul.lst-kix_peaeqjcyrerl-1{list-style-type:none}.lst-kix_xrd3a6cw62t3-0>li:before{content:"\0025cf  "}ul.lst-kix_xrd3a6cw62t3-6{list-style-type:none}ul.lst-kix_peaeqjcyrerl-0{list-style-type:none}ul.lst-kix_peaeqjcyrerl-7{list-style-type:none}ul.lst-kix_peaeqjcyrerl-6{list-style-type:none}ul.lst-kix_peaeqjcyrerl-5{list-style-type:none}.lst-kix_xrd3a6cw62t3-3>li:before{content:"\0025cf  "}ul.lst-kix_peaeqjcyrerl-4{list-style-type:none}.lst-kix_peaeqjcyrerl-7>li:before{content:"\0025cb  "}.lst-kix_xrd3a6cw62t3-4>li:before{content:"\0025cb  "}ul.lst-kix_peaeqjcyrerl-8{list-style-type:none}.lst-kix_peaeqjcyrerl-2>li:before{content:"\0025a0  "}.lst-kix_peaeqjcyrerl-3>li:before{content:"\0025cf  "}.lst-kix_xrd3a6cw62t3-2>li:before{content:"\0025a0  "}.lst-kix_xrd3a6cw62t3-5>li:before{content:"\0025a0  "}.lst-kix_peaeqjcyrerl-0>li:before{content:"\0025cf  "}ul.lst-kix_xrd3a6cw62t3-0{list-style-type:none}ul.lst-kix_xrd3a6cw62t3-1{list-style-type:none}.lst-kix_peaeqjcyrerl-1>li:before{content:"\0025cb  "}ul.lst-kix_xrd3a6cw62t3-2{list-style-type:none}ul.lst-kix_xrd3a6cw62t3-3{list-style-type:none}.lst-kix_peaeqjcyrerl-6>li:before{content:"\0025cf  "}.lst-kix_peaeqjcyrerl-4>li:before{content:"\0025cb  "}.lst-kix_xrd3a6cw62t3-1>li:before{content:"\0025cb  "}.lst-kix_peaeqjcyrerl-8>li:before{content:"\0025a0  "}.lst-kix_xrd3a6cw62t3-8>li:before{content:"\0025a0  "}.lst-kix_peaeqjcyrerl-5>li:before{content:"\0025a0  "}.lst-kix_xrd3a6cw62t3-7>li:before{content:"\0025cb  "}.lst-kix_xrd3a6cw62t3-6>li:before{content:"\0025cf  "}ol{margin:0;padding:0}.c6{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c5{padding-left:0pt;margin-left:36pt}.c7{font-size:13pt;font-family:"Trebuchet MS"}.c3{margin:0;padding:0}.c1{height:11pt;direction:ltr}.c8{height:13pt}.c9{padding-top:10pt}.c4{direction:ltr}.c2{font-weight:bold}.c0{font-family:"Ubuntu Mono"}.title{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt}.subtitle{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt}h2{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h3{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h4{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt}h5{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}h6{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}</style></head><body class="c6"><p class="c4"><span>Samuel Sweet</span></p><p class="c4"><span>12 December 2013</span></p><p class="c4"><span>CS 5610-1</span></p><p class="c4"><span>Project Report</span></p><p class="c1"><span></span></p><h2 class="c4"><a name="h.fsnxaivehj7n"></a><span>Summary</span></h2><p class="c4"><span>The goal is to create an application to display volume datasets using a raymarching algorithm, with a user interface to browse and change the current volume dataset, and view the dataset.</span></p><h2 class="c4 c9"><a name="h.dm6kizci9ghd"></a><span>Running</span></h2><p class="c4"><span>To run the application, change to the application directory and compile the app with:</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">make clean &amp;&amp; make -j4</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span>From there, you can run the program and pass a command-line parameter that represents the volume data you wish to view as follows:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c0">./output [path_to_filename].pvm</span></p><p class="c1"><span class="c2 c7"></span></p><p class="c4"><span>Note the </span><span>&ldquo;.pvm&rdquo; at the end. If the file name does not have this extension, it will fail to load.</span></p><h2 class="c4"><a name="h.e6ucoff0tgf1"></a><span>Implemented Tasks</span></h2><ul class="c3 lst-kix_xrd3a6cw62t3-0 start"><li class="c5 c4"><span class="c2">C++ classes and template methods in place encapsulating the gist of the algorithm</span><span><br>Entails abstracting the important pieces of the algorithm containing necessary OpenGL state calls via helper classes and template methods.<br><br>The call used to set up a unit bounding box for a particular volume dataset to be rendered, and create and use frame and render buffers of backfaces of the bounding box to compute ray directions for raymarching are used frequently and somewhat difficult to implement, which make for an ideal case to encapsulate in easy-to-use classes.<br></span></li><li class="c5 c4"><span class="c2">Fully working bounding box implementation<br></span><span>The unit bounding box, which is rendered to a buffer to perform ray direction computations and constrain the rendered volume is fully implemented and working.</span></li></ul><p class="c1"><span></span></p><ul class="c3 lst-kix_xrd3a6cw62t3-0"><li class="c5 c4"><span class="c2">Shader programs<br></span><span>A passthrough shader program to render a bounding box, and shader program to display a fullscreen texture are implemented. A shader that performs the raymarching steps on the volume is implemented, without stopping criterion optimization.</span></li></ul><p class="c1"><span></span></p><ul class="c3 lst-kix_xrd3a6cw62t3-0"><li class="c5 c4"><span class="c2">Controls</span><span><br>Controls are implemented to change the viewing angle of the volume and zoom in/out of the volume. </span></li></ul><p class="c1"><span class="c2"></span></p><ul class="c3 lst-kix_xrd3a6cw62t3-0"><li class="c4 c5"><span class="c2">Output<br></span><span>At present, a volume is able to be rendered successfully (in monochrome), but appears to be squished to the box. This is most likely due to the direction in which the rays are calculated (back-to-front). I need to flip this so the direction is computed as front-to-back to match the description of the paper, but this would mean retuning the color blending equation to match. I am slightly confused as to whether the frontfaces need to be rendered to another texture and used to compute ray directions, or use the texture coordinates of the front faces instead (which is what I am doing at present).</span></li></ul><h2 class="c4 c8"><a name="h.cg4w97kxyseg"></a></h2><h2 class="c4"><a name="h.syusiwu75q9z"></a><span>Fixes Needed</span></h2><p class="c4"><span>At the moment, the filebrowser does not seem to respond to a user&rsquo;s file selection and does not load a new volume. I will see to it that these issues are fixed before the Tuesday demo.</span></p><p class="c1"><span></span></p><ul class="c3 lst-kix_peaeqjcyrerl-0 start"><li class="c5 c4"><span>Fixing filebrowser so it responds</span></li><li class="c5 c4"><span>Correcting ray direction and blending equation</span></li></ul></body></html>